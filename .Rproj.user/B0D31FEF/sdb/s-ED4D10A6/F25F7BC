{
    "collab_server" : "",
    "contents" : "#' Probabilistic Reversal Learning Task \n#' \n#' @description \n#' Hierarchical Bayesian Modeling of the Probabilistic Reversal Learning (PRL) Task using the following parameters: \"Apun\" (punishment learning rate), \"Arew\" (reward learning rate), and \"beta\" (inverse temperature).\n#' From the hBayesDM package by Woo-Young Ahn.\n#' This is been modified by Ben Smith to use multiple cores.\n#' \n#' \\strong{MODEL:}\n#' Reward-Punishment Model (Ouden et al., 2013, Neuron)\n#' \n#' @param data A .txt file containing the data to be modeled. Data columns should be labelled as follows: \"subjID\", \"choice\", and \"outcome\". See \\bold{Details} below for more information. \n#' @param niter Number of iterations, including warm-up.\n#' @param nwarmup Number of iterations used for warm-up only.\n#' @param nchain Number of chains to be run.\n#' @param ncore Integer value specifying how many CPUs to run the MCMC sampling on. Defaults to 1. \n#' @param nthin Every \\code{i == nthin} sample will be used to generate the posterior distribution. Defaults to 1. A higher number can be used when auto-correlation within the MCMC sampling is high. \n#' @param inits Character value specifying how the initial values should be generated. Options are \"fixed\" or \"random\" or your own initial values.\n#' @param indPars Character value specifying how to summarize individual parameters. Current options are: \"mean\", \"median\", or \"mode\".\n#' @param saveDir Path to directory where .RData file of model output (\\code{modelData}) can be saved. Leave blank if not interested.\n#' @param email Character value containing email address to send notification of completion. Leave blank if not interested. \n#' @param modelRegressor Exporting model-based regressors? TRUE or FALSE. Currently not available for this model.\n#' @param adapt_delta Floating point number representing the target acceptance probability of a new sample in the MCMC chain. Must be between 0 and 1. See \\bold{Details} below.\n#' @param stepsize Integer value specifying the size of each leapfrog step that the MCMC sampler can take on each new iteration. See \\bold{Details} below.\n#' @param max_treedepth Integer value specifying how many leapfrog steps that the MCMC sampler can take on each new iteration. See \\bold{Details} below. \n#'  \n#' @return \\code{modelData}  A class \\code{\"hBayesDM\"} object with the following components:\n#' \\describe{\n#'  \\item{\\code{model}}{Character string with the name of the model (\\code{\"prl_rp\"}).}\n#'  \\item{\\code{allIndPars}}{\\code{\"data.frame\"} containing the summarized parameter \n#'    values (as specified by \\code{\"indPars\"}) for each subject.}\n#'  \\item{\\code{parVals}}{A \\code{\"list\"} where each element contains posterior samples\n#'    over different model parameters. }\n#'  \\item{\\code{fit}}{A class \\code{\"stanfit\"} object containing the fitted model.}\n#'  \\item{\\code{rawdata}}{\\code{\"data.frame\"} containing the raw data used to fit the model, as specified by the user.}\n#' }\n#' \n#' @importFrom rstan stan rstan_options extract\n#' @importFrom mail sendmail\n#' @importFrom stats median qnorm density\n#' @importFrom utils read.table\n#'\n#' @details \n#' This section describes some of the function arguments in greater detail.\n#' \n#' \\strong{data} should be assigned a character value specifying the full path and name of the file, including the file extension \n#' (e.g. \".txt\"), that contains the behavioral data of all subjects of interest for the current analysis. \n#' The file should be a text (.txt) file whose rows represent trial-by-trial observations and columns \n#' represent variables. For the Probabilistic Reversal Learning Task, there should be three columns of data \n#' with the labels \"subjID\", \"choice\", and \"outcome\". It is not necessary for the columns to be in this particular order, \n#' however it is necessary that they be labelled correctly and contain the information below:\n#' \\describe{\n#'  \\item{\\code{\"subjID\"}}{A unique identifier for each subject within data-set to be analyzed.}\n#'  \\item{\\code{\"choice\"}}{An integer value representing the chosen choice option within the given trial (e.g., 1 or 2 in PRL).}\n#'  \\item{\\code{\"outcome\"}}{A 1 or -1 for outcome within each given trial (1 = reward, -1 = loss).}\n#' } \n#' \\strong{*}Note: The data.txt file may contain other columns of data (e.g. \"Reaction_Time\", \"trial_number\", etc.), but only the data with the column\n#' names listed above will be used for analysis/modeling. As long as the columns above are present and labelled correctly,\n#' there is no need to remove other miscellaneous data columns.    \n#'  \n#' \\strong{nwarmup} is a numerical value that specifies how many MCMC samples should not be stored upon the \n#' beginning of each chain. For those familiar with Bayesian methods, this value is equivalent to a burn-in sample. \n#' Due to the nature of MCMC sampling, initial values (where the sampling chain begins) can have a heavy influence \n#' on the generated posterior distributions. The \\code{nwarmup} argument can be set to a high number in order to curb the \n#' effects that initial values have on the resulting posteriors.  \n#' \n#' \\strong{nchain} is a numerical value that specifies how many chains (i.e. independent sampling sequences) should be\n#' used to draw samples from the posterior distribution. Since the posteriors are generated from a sampling \n#' process, it is good practice to run multiple chains to ensure that a representative posterior is attained. When\n#' sampling is completed, the multiple chains may be checked for convergence with the \\code{plot(myModel, type = \"trace\")}\n#' command. The chains should resemble a \"furry caterpillar\".\n#' \n#' \\strong{nthin} is a numerical value that specifies the \"skipping\" behavior of the MCMC samples being chosen \n#' to generate the posterior distributions. By default, \\code{nthin} is equal to 1, hence every sample is used to \n#' generate the posterior. \n#' \n#' \\strong{Contol Parameters:} adapt_delta, stepsize, and max_treedepth are advanced options that give the user more control \n#' over Stan's MCMC sampler. The Stan creators recommend that only advanced users change the default values, as alterations\n#' can profoundly change the sampler's behavior. Refer to Hoffman & Gelman (2014, Journal of Machine Learning Research) for \n#' more information on the functioning of the sampler control parameters. One can also refer to section 58.2 of the  \n#' \\href{http://mc-stan.org/documentation/}{Stan User's Manual} for a less technical description of these arguments. \n#' \n#' @export \n#' \n#' @references \n#' Hoffman, M. D., & Gelman, A. (2014). The No-U-turn sampler: adaptively setting path lengths in Hamiltonian Monte Carlo. The \n#' Journal of Machine Learning Research, 15(1), 1593-1623.\n#' \n#' Ouden, den, H. E. M., Daw, N. D., Fernandez, G., Elshout, J. A., Rijpkema, M., Hoogman, M., et al. (2013). Dissociable \n#' Effects of Dopamine and Serotonin on Reversal Learning. Neuron, 80(4), 1090-1100. http://doi.org/10.1016/j.neuron.2013.08.030\n#' \n#' @seealso \n#' We refer users to our in-depth tutorial for an example of using hBayesDM: \\url{https://rpubs.com/CCSL/hBayesDM}\n#' \n#' @examples \n#' \\dontrun{\n#' # Run the model and store results in \"output\"\n#' output <- prl_rp(data = \"example\", niter = 2000, nwarmup = 1000, nchain = 3, ncore = 3)\n#' \n#' # Visually check convergence of the sampling chains (should like like 'hairy caterpillars')\n#' plot(output, type = 'trace')\n#' \n#' # Check Rhat values (all Rhat values should be less than or equal to 1.1)\n#' rhat(output)\n#' \n#' # Plot the posterior distributions of the hyper-parameters (distributions should be unimodal)\n#' plot(output)\n#' \n#' # Show the WAIC and LOOIC model fit estimates \n#' printFit(output)\n#' }\n\nprl_rp_ben <- function(data          = \"choose\",\n                   niter         = 3000, \n                   nwarmup       = 1000, \n                   nchain        = 4,\n                   ncore         = 1, \n                   nthin         = 1,\n                   inits         = \"random\",  \n                   indPars       = \"mean\", \n                   saveDir       = NULL,\n                   email         = NULL,\n                   modelRegressor= FALSE,\n                   adapt_delta   = 0.95,\n                   stepsize      = 1,\n                   max_treedepth = 10 ) {\n  \n  # Path to .stan model file\n  if (modelRegressor) { # model regressors (for model-based neuroimaging, etc.)\n    stop(\"** Model-based regressors are not available for this model **\\n\")\n  } else {\n    modelPath <- system.file(\"exec\", \"prl_rp.stan\", package=\"hBayesDM\")\n  }\n  \n  # To see how long computations take\n  startTime <- Sys.time()    \n  \n  # For using example data\n  if (data==\"example\") {\n    data <- system.file(\"extdata\", \"prl_exampleData.txt\", package = \"hBayesDM\")\n  } else if (data==\"choose\") {\n    data <- file.choose()\n  }\n  \n  # Load data\n  if (file.exists(data)) {\n    rawdata <- read.table( data, header = T, sep=\"\\t\")\n  } else {\n    stop(\"** The data file does not exist. Please check it again. **\\n  e.g., data = '/MyFolder/SubFolder/dataFile.txt', ... **\\n\")\n  }  \n  # Remove rows containing NAs\n  NA_rows_all = which(is.na(rawdata), arr.ind = T)  # rows with NAs\n  NA_rows = unique(NA_rows_all[, \"row\"])\n  if (length(NA_rows) > 0) {\n    rawdata = rawdata[-NA_rows, ]\n    cat(\"The number of rows with NAs=\", length(NA_rows), \". They are removed prior to modeling the data. \\n\", sep=\"\")\n  }\n  \n  # Individual Subjects\n  subjList <- unique(rawdata[,\"subjID\"])  # list of subjects x blocks\n  numSubjs <- length(subjList)  # number of subjects\n  \n  # Specify the number of parameters and parameters of interest \n  numPars <- 3\n  POI     <- c(\"mu_Apun\", \"mu_Arew\", \"mu_beta\", \n               \"sigma\",\n               \"Apun\", \"Arew\", \"beta\", \n               \"log_lik\")\n  \n  modelName <- \"prl_rp\"\n  \n  # Information for user\n  cat(\"\\nModel name = \", modelName, \"\\n\")\n  cat(\"Data file  = \", data, \"\\n\")\n  cat(\"\\nDetails:\\n\")\n  cat(\" # of chains                   = \", nchain, \"\\n\")\n  cat(\" # of cores used               = \", ncore, \"\\n\")\n  cat(\" # of MCMC samples (per chain) = \", niter, \"\\n\")\n  cat(\" # of burn-in samples          = \", nwarmup, \"\\n\")\n  cat(\" # of subjects                 = \", numSubjs, \"\\n\")\n  \n  ################################################################################\n  # THE DATA.  ###################################################################\n  ################################################################################\n  \n  Tsubj <- as.vector( rep( 0, numSubjs ) ) # number of trials for each subject\n  \n  for ( i in 1:numSubjs )  {\n    curSubj  <- subjList[ i ]\n    Tsubj[i] <- sum( rawdata$subjID == curSubj )  # Tsubj[N]\n  }\n  \n  # Setting maxTrials\n  maxTrials <- max(Tsubj)\n  \n  # Information for user continued\n  cat(\" # of (max) trials per subject = \", maxTrials, \"\\n\\n\")\n  \n  choice <- array(1, c(numSubjs, maxTrials) )\n  rewlos <- array(0, c(numSubjs, maxTrials) )\n  \n  for (i in 1:numSubjs) {\n    curSubj      <- subjList[i]\n    useTrials    <- Tsubj[i]\n    tmp          <- subset(rawdata, rawdata$subjID == curSubj)\n    choice[i, 1:useTrials] <- tmp$choice\n    rewlos[i, 1:useTrials] <- ifelse(tmp$outcome > 0, 1, 0)\n  }\n  \n  dataList <- list(\n    N       = numSubjs,\n    T       = maxTrials,\n    Tsubj   = Tsubj,\n    choice  = choice,\n    rewlos  = rewlos,\n    numPars = numPars\n  )\n  \n  # inits\n  if (inits[1] != \"random\") {\n    if (inits[1] == \"fixed\") {\n      inits_fixed <- c(0.1, 0.1, 1.0)\n    } else {\n      if (length(inits)==numPars) {\n        inits_fixed <- inits\n      } else {\n        stop(\"Check your inital values!\")\n      }\n    }  \n    genInitList <- function() {\n      list(\n        mu_p    = c( qnorm(inits_fixed[1]), qnorm(inits_fixed[2]), qnorm(inits_fixed[3] / 10) ),\n        sigma   = c(1.0, 1.0, 1.0),\n        Apun_pr = rep(qnorm(inits_fixed[1]), numSubjs),\n        Arew_pr = rep(qnorm(inits_fixed[2]), numSubjs),\n        beta_pr = rep(qnorm(inits_fixed[3]/10), numSubjs)\n      )\n    }\n  } else {\n    genInitList <- \"random\"\n  }\n  \n  if (ncore > 1) {\n    numCores <- parallel::detectCores()\n    if (numCores < ncore){\n      options(mc.cores = numCores)\n      warning('Number of cores specified for parallel computing greater than number of locally available cores. Using all locally available cores.')\n    }\n    else{\n      options(mc.cores = ncore)\n    }\n  }\n  else {\n    options(mc.cores = 1)\n  }\n  \n  cat(\"***********************************\\n\")\n  cat(\"**  Loading a precompiled model  **\\n\")\n  cat(\"***********************************\\n\")\n  \n  # Fit the Stan model\n  model.filename<-\"rlp_hbayesDM_model.stan\"\n   \n  modelString = readChar(model.filename, file.info(model.filename)$size)\n  stanDso <- stan_model( model_code=modelString )\n  #we need to compile a STAN model.\n  #m = stanmodels$prl_rp\n  fit <- rstan::sampling(stanDso,\n                         data   = dataList, \n                         pars   = POI,\n                         warmup = nwarmup,\n                         init   = genInitList, \n                         iter   = niter, \n                         chains = nchain,\n                         thin   = nthin)\n  \n  ## Extract parameters\n  parVals <- rstan::extract(fit, permuted=T)\n  \n  Apun <- parVals$Apun\n  Arew <- parVals$Arew\n  beta <- parVals$beta\n  \n  # Individual parameters (e.g., individual posterior means)\n  allIndPars <- array(NA, c(numSubjs, numPars))\n  allIndPars <- as.data.frame(allIndPars)\n  \n  for (i in 1:numSubjs) {\n    if (indPars==\"mean\") {\n      allIndPars[i, ] <- c( mean(Apun[, i]), \n                            mean(Arew[, i]), \n                            mean(beta[, i]) )\n    } else if (indPars==\"median\") {\n      allIndPars[i, ] <- c( median(Apun[, i]), \n                            median(Arew[, i]), \n                            median(beta[, i]) )\n    } else if (indPars==\"mode\") {\n      allIndPars[i, ] <- c( estimate_mode(Apun[, i]),\n                            estimate_mode(Arew[, i]),\n                            estimate_mode(beta[, i]) )\n    }\n  }\n  \n  allIndPars           <- cbind(allIndPars, subjList)\n  colnames(allIndPars) <- c(\"Apun\", \n                            \"Arew\", \n                            \"beta\", \n                            \"subjID\")\n  \n  # Wrap up data into a list\n  modelData        <- list(modelName, allIndPars, parVals, fit)\n  names(modelData) <- c(\"model\", \"allIndPars\", \"parVals\", \"fit\")\n  class(modelData) <- \"hBayesDM\"\n  \n  # Total time of computations\n  endTime  <- Sys.time()\n  timeTook <- endTime - startTime\n  \n  # If saveDir is specified, save modelData as a file. If not, don't save\n  # Save each file with its model name and time stamp (date & time (hr & min))\n  if (!is.null(saveDir)) {  \n    currTime  <- Sys.time()\n    currDate  <- Sys.Date()\n    currHr    <- substr(currTime, 12, 13)\n    currMin   <- substr(currTime, 15, 16)\n    timeStamp <- paste0(currDate, \"_\", currHr, \"_\", currMin)\n    dataFileName = sub(pattern = \"(.*)\\\\..*$\", replacement = \"\\\\1\", basename(data))\n    save(modelData, file=file.path(saveDir, paste0(modelName, \"_\", dataFileName, \"_\", timeStamp, \".RData\"  ) ) )\n  }\n  \n  # Send email to notify user of completion\n  if (is.null(email)==F) {\n    mail::sendmail(email, paste(\"model=\", modelName, \", fileName = \", data),\n                   paste(\"Check \", getwd(), \". It took \", as.character.Date(timeTook), sep=\"\") )\n  }\n  # Inform user of completion\n  cat(\"\\n************************************\\n\")\n  cat(\"**** Model fitting is complete! ****\\n\")\n  cat(\"************************************\\n\")\n  \n  return(modelData)\n}",
    "created" : 1493749176427.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "212766242",
    "id" : "F25F7BC",
    "lastKnownWriteTime" : 1493675747,
    "last_content_update" : 1493675747,
    "path" : "~/Google Drive/joint-modeling/reversal-learning/behavioral-analysis/prlp_ben.R",
    "project_path" : "prlp_ben.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}