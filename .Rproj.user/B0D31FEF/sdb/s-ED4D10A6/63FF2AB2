{
    "collab_server" : "",
    "contents" : "#variables for the oroiginal model were:\n#- zbeta0...2\n#- zbeta0...2mu\n#- zbeta0...2sigma\n#- zsigma\n#- nu\n#Stan wrapper code adapted from Kuschke (2015)\n#Bayes model adapted from Woo-Young Ahn's hierarhical modeling paper.\n#chur.\n#BJS20170501 Happy May Day\n# Stan-Ymet-XmetSsubj-MrobustHierQuadWt.R \n# Accompanies the book:\n#  Kruschke, J. K. (2015). Doing Bayesian Data Analysis, Second Edition: \n#  A Tutorial with R, JAGS, and Stan. Academic Press / Elsevier.\n\nsource(\"DBDA2E-utilities.R\")\n\n#===============================================================================\n\ngenMCMC = function( data , wName=NULL ,\n                    numSavedSteps=10000 , thinSteps = 1 , saveName=NULL ) { \n  require(rstan)\n  #-----------------------------------------------------------------------------\n  # THE DATA.\n  s = length(as.numeric(data[,subjID]))\n  # if ( !is.null(wName) ) {\n  #   w = data[,wName]\n  # } else {\n  #   w = rep(1,length(y))\n  # }\n  # # Do some checking that data make sense:\n  # if ( any( !is.finite(y) ) ) { stop(\"All y values must be finite.\") }\n  # if ( any( !is.finite(x) ) ) { stop(\"All x values must be finite.\") }\n  #Ntotal = length(y)\n  # Specify the data in a list, for later shipment to JAGS:\n  dataList = list(\n    subjID = data$subjID,\n    choice = data$choice,\n    outcome = data$outcome,\n    s = s ,\n    Nsubj = max(s)  , # should equal length(unique(s))\n    Ntotal = length(y)\n  )\n  #-----------------------------------------------------------------------------\n  # THE MODEL.\n  \n  modelString = read.text(\"rlp_hbayesDM_model.stan\")\n  #data\n  \n  \"\n  data {\n    int<lower=1> Nsubj ;\n    int<lower=1> Ntotal ;\n    real y[Ntotal] ;\n    real x[Ntotal] ;\n    real<lower=0> w[Ntotal] ;\n    int<lower=1> s[Ntotal] ;\n  }\n  transformed data {\n    // Standardize the data:\n    real zx[Ntotal] ;\n    real zy[Ntotal] ;\n    real zw[Ntotal] ;\n    real wm ;\n    real xm ;\n    real ym ;\n    real xsd ;\n    real ysd ;\n    xm <- mean(x) ;\n    ym <- mean(y) ;\n    wm <- mean(w) ;\n    xsd <- sd(x) ;\n    ysd <- sd(y) ;\n    for ( i in 1:Ntotal ) { // could be vectorized...?\n      zx[i] <- ( x[i] - xm ) / xsd ; \n      zy[i] <- ( y[i] - ym ) / ysd ; \n      zw[i] <- w[i] / wm  ;\n    }\n  }\n  parameters {\n    real zbeta0[Nsubj] ;\n    real zbeta1[Nsubj] ;\n    real zbeta2[Nsubj] ;\n    real<lower=0> zsigma ;\n    real zbeta0mu ; \n    real zbeta1mu ; \n    real zbeta2mu ; \n    real<lower=0> zbeta0sigma ;\n    real<lower=0> zbeta1sigma ;\n    real<lower=0> zbeta2sigma ;\n    real<lower=0> nu ;\n  }\n  transformed parameters {\n    real beta0[Nsubj] ;\n    real beta1[Nsubj] ;\n    real beta2[Nsubj] ;\n    real<lower=0> sigma ;\n    real beta0mu ; \n    real beta1mu ; \n    real beta2mu ; \n    // Transform to original scale:\n    for ( j in 1:Nsubj ) { // could be vectorized...?\n      beta2[j] <- zbeta2[j]*ysd/square(xsd) ;\n      beta1[j] <- zbeta1[j]*ysd/xsd - 2*zbeta2[j]*xm*ysd/square(xsd) ;\n      beta0[j] <- zbeta0[j]*ysd  + ym - zbeta1[j]*xm*ysd/xsd + zbeta2[j]*square(xm)*ysd/square(xsd) ;\n    }\n    beta2mu <- zbeta2mu*ysd/square(xsd) ;\n    beta1mu <- zbeta1mu*ysd/xsd - 2*zbeta2mu*xm*ysd/square(xsd) ;\n    beta0mu <- zbeta0mu*ysd  + ym - zbeta1mu*xm*ysd/xsd + zbeta2mu*square(xm)*ysd/square(xsd) ;\n    sigma <- zsigma * ysd ;\n  } \n  model {\n    zbeta0mu ~ normal( 0 , 10 ) ;\n    zbeta1mu ~ normal( 0 , 10 ) ;\n    zbeta2mu ~ normal( 0 , 10 ) ;\n    zsigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;\n    zbeta0sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;\n    zbeta1sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;\n    zbeta2sigma ~ uniform( 1.0E-3 , 1.0E+3 ) ;\n    nu ~ exponential(1/30.0) ;\n    zbeta0 ~ normal( zbeta0mu , zbeta0sigma ) ; // vectorized\n    zbeta1 ~ normal( zbeta1mu , zbeta1sigma ) ; // vectorized\n    zbeta2 ~ normal( zbeta2mu , zbeta2sigma ) ; // vectorized\n    for ( i in 1:Ntotal ) {\n      zy[i] ~ student_t( \n                nu ,\n                zbeta0[s[i]] + zbeta1[s[i]] * zx[i] + zbeta2[s[i]] * square(zx[i]) , \n                zw[i]*zsigma ) ;\n    }\n  }  \n  \" # close quote for modelString\n  \n  # Write out modelString to a text file\n  writeLines( modelString , con=\"TEMPmodel.txt\" )\n  #-----------------------------------------------------------------------------\n  # INTIALIZE THE CHAINS.\n  \n  # Use lm() to find reasonable coefficients overall, then start all individual\n  # units and overall at those values.\n  # N.B. THIS DOES NOT ALWAYS WORK AND DOES NOT ALWAYS IMPROVE THE MCMC SAMPLE.\n  # IF IT'S A PROBLEM, COMMENT OUT THE inits ARGUMENT IN THE run.jags COMMAND.\n  zx = ( x - mean(x) ) / sd(x)\n  zxsq = zx^2\n  zy = ( y - mean(y) ) / sd(y)\n  lmInfo = lm( zy ~ zx + zxsq )\n  b0init = lmInfo$coef[1]\n  b1init = lmInfo$coef[2]\n  b2init = lmInfo$coef[3]\n  sigmaInit = sqrt(mean(lmInfo$res^2))\n  nuInit = 10 # arbitrary\n  initsList = list(\n    zsigma=sigmaInit  ,\n    nu=nuInit ,\n    zbeta0mu=b0init ,\n    zbeta1mu=b1init ,\n    zbeta2mu=b2init ,\n    zbeta0=rep(b0init,max(s)) ,\n    zbeta1=rep(b1init,max(s)) ,\n    zbeta2=rep(b2init,max(s)) # other params filled in by JAGS\n  )\n  \n  #-----------------------------------------------------------------------------\n  # RUN THE CHAINS\n  parameters = c( \"beta0\" ,  \"beta1\" ,  \"beta2\" ,\n                  \"beta0mu\" , \"beta1mu\" , \"beta2mu\" ,\n                  \"zbeta0\" , \"zbeta1\" , \"zbeta2\" ,\n                  \"zbeta0mu\" , \"zbeta1mu\" , \"zbeta2mu\" ,\n                  \"sigma\" , \"nu\" , \n                  \"zsigma\", \"zbeta0sigma\" , \"zbeta1sigma\", \"zbeta2sigma\" )\n  adaptSteps = 1000  # Number of steps to \"tune\" the samplers\n  burnInSteps = 2000 \n  nChains = 3 \n  \n  # Translate to C++ and compile to DSO:\n  stanDso <- stan_model( model_code=modelString ) \n  # Get MC sample of posterior:\n  stanFit <- sampling( object=stanDso , \n                       data = dataList , \n                       #pars = parameters , # optional\n                       #init = initsList , # optional  \n                       chains = nChains ,\n                       iter = ( ceiling(numSavedSteps/nChains)*thinSteps\n                                +burnInSteps ) , \n                       warmup = burnInSteps , \n                       thin = thinSteps )\n  # For consistency with JAGS-oriented functions in DBDA2E collection, \n  # convert stan format to coda format:\n  codaSamples = mcmc.list( lapply( 1:ncol(stanFit) , \n                                   function(x) { mcmc(as.array(stanFit)[,x,]) } ) )\n  # resulting codaSamples object has these indices: \n  #   codaSamples[[ chainIdx ]][ stepIdx , paramIdx ]\n  if ( !is.null(saveName) ) {\n    save( codaSamples , file=paste(saveName,\"Mcmc.Rdata\",sep=\"\") )\n    save( stanFit , file=paste(saveName,\"StanFit.Rdata\",sep=\"\") )\n    save( stanDso , file=paste(saveName,\"StanDso.Rdata\",sep=\"\") )\n  }  \n  \n  return( codaSamples )\n} # end function\n\n#===============================================================================\n\nsmryMCMC = function(  codaSamples , \n                      saveName=NULL ) {\n  mcmcMat = as.matrix(codaSamples,chains=FALSE)\n  paramNames = colnames(mcmcMat)\n  summaryInfo = NULL\n  for ( pName in paramNames ) {\n    summaryInfo = rbind( summaryInfo ,  summarizePost( mcmcMat[,pName] ) )\n  }\n  rownames(summaryInfo) = paramNames\n  if ( !is.null(saveName) ) {\n    write.csv( summaryInfo , file=paste(saveName,\"SummaryInfo.csv\",sep=\"\") )\n  }\n  return( summaryInfo )\n}\n\n#===============================================================================\n\nplotMCMC = function( codaSamples , data , \n                     xName=\"x\" , yName=\"y\" , sName=\"s\" , wName=\"w\" ,\n                     compValBeta0=NULL , ropeBeta0=NULL , \n                     compValBeta1=NULL , ropeBeta1=NULL , \n                     compValSigma=NULL , ropeSigma=NULL , \n                     showCurve=FALSE ,  pairsPlot=FALSE ,\n                     saveName=NULL , saveType=\"jpg\" ) {\n  # showCurve is TRUE or FALSE and indicates whether the posterior should\n  #   be displayed as a histogram (by default) or by an approximate curve.\n  # pairsPlot is TRUE or FALSE and indicates whether scatterplots of pairs\n  #   of parameters should be displayed.\n  #-----------------------------------------------------------------------------\n  y = data[,yName]\n  x = data[,xName]\n  s = factor(data[,sName])\n  nSubj = length(unique(s)) # should be same as max(s)\n  mcmcMat = as.matrix(codaSamples,chains=TRUE)\n  chainLength = NROW( mcmcMat )\n  beta0mu = mcmcMat[,\"beta0mu\"]\n  beta1mu = mcmcMat[,\"beta1mu\"]\n  beta2mu = mcmcMat[,\"beta2mu\"]\n  zbeta0mu = mcmcMat[,\"zbeta0mu\"]\n  zbeta1mu = mcmcMat[,\"zbeta1mu\"]\n  zbeta2mu = mcmcMat[,\"zbeta2mu\"]\n  sigma = mcmcMat[,\"sigma\"]\n  nu = mcmcMat[,\"nu\"]\n  log10nu = log10(nu)\n  #-----------------------------------------------------------------------------\n  if ( pairsPlot ) {\n    # Plot the parameters pairwise, to see correlations:\n    openGraph()\n    nPtToPlot = 1000\n    plotIdx = floor(seq(1,chainLength,by=chainLength/nPtToPlot))\n    panel.cor = function(x, y, digits=2, prefix=\"\", cex.cor, ...) {\n      usr = par(\"usr\"); on.exit(par(usr))\n      par(usr = c(0, 1, 0, 1))\n      r = (cor(x, y))\n      txt = format(c(r, 0.123456789), digits=digits)[1]\n      txt = paste(prefix, txt, sep=\"\")\n      if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)\n      text(0.5, 0.5, txt, cex=1.25 ) # was cex=cex.cor*r\n    }\n    pairs( cbind( beta0mu , beta1mu , beta2mu , sigma , log10nu )[plotIdx,] ,\n           labels=c( expression(mu[beta*0]) , expression(mu[beta*1]) , \n                     expression(mu[beta*2]) , \n                     expression(sigma) ,  expression(log10(nu)) ) , \n           lower.panel=panel.cor , col=\"skyblue\" )\n    if ( !is.null(saveName) ) {\n      saveGraph( file=paste(saveName,\"PostPairs\",sep=\"\"), type=saveType)\n    }\n  }\n  #-----------------------------------------------------------------------------\n  # Marginal histograms:\n  # Set up window and layout:\n  nPtToPlot = 1000\n  plotIdx = floor(seq(1,chainLength,by=chainLength/nPtToPlot))\n  openGraph(width=8,height=8)\n  layout( matrix( 1:9 , nrow=3, byrow=TRUE ) )\n  par( mar=c(4,4,2.5,0.5) , mgp=c(2.5,0.7,0) )\n  histInfo = plotPost( beta0mu , cex.lab = 1.75 , showCurve=showCurve ,\n                       compVal=compValBeta0 , ROPE=ropeBeta0 ,\n                       xlab=bquote(mu[beta*0]) , main=paste(\"Intercept, Group Level\") )\n  histInfo = plotPost( beta1mu , cex.lab = 1.75 , showCurve=showCurve ,\n                       compVal=compValBeta1 , ROPE=ropeBeta1 ,\n                       xlab=bquote(mu[beta*1]) , main=paste(\"Slope, Group Level\") )\n  histInfo = plotPost( beta2mu , cex.lab = 1.75 , showCurve=showCurve ,\n                       #compVal=compValBeta1 , ROPE=ropeBeta1 ,\n                       xlab=bquote(mu[beta*2]) , main=paste(\"Quad, Group Level\") )\n  histInfo = plotPost( zbeta0mu , cex.lab = 1.75 , showCurve=showCurve ,\n                       #compVal=compValBeta0 , ROPE=ropeBeta0 ,\n                       xlab=bquote(zmu[beta*0]) , main=paste(\"Intercept, Group Level\") )\n  histInfo = plotPost( zbeta1mu , cex.lab = 1.75 , showCurve=showCurve ,\n                       #compVal=compValBeta1 , ROPE=ropeBeta1 ,\n                       xlab=bquote(zmu[beta*1]) , main=paste(\"Slope, Group Level\") )\n  histInfo = plotPost( zbeta2mu , cex.lab = 1.75 , showCurve=showCurve ,\n                       #compVal=compValBeta1 , ROPE=ropeBeta1 ,\n                       xlab=bquote(zmu[beta*2]) , main=paste(\"Quad, Group Level\") )\n  #plot( beta1mu[plotIdx] , beta0mu[plotIdx] , \n  #      xlab=bquote(mu[beta*1]) , ylab=bquote(mu[beta*0]) ,\n  #      col=\"skyblue\" , cex.lab = 1.75 )\n  histInfo = plotPost( sigma , cex.lab = 1.75 , showCurve=showCurve ,\n                       compVal=compValSigma , ROPE=ropeSigma ,\n                       xlab=bquote(sigma) , main=paste(\"Scale, Subj Level\") )\n  histInfo = plotPost( log10nu , cex.lab = 1.75 , showCurve=showCurve ,\n                       compVal=NULL , ROPE=NULL ,\n                       xlab=bquote(log10(nu)) , main=paste(\"Normality, Subj Level\") )\n  plot( log10nu[plotIdx] , sigma[plotIdx] , \n        xlab=bquote(log10(nu)) ,ylab=bquote(sigma) , \n        col=\"skyblue\" , cex.lab = 1.75 )\n  if ( !is.null(saveName) ) {\n    saveGraph( file=paste(saveName,\"PostMarg\",sep=\"\"), type=saveType)\n  }\n  #-----------------------------------------------------------------------------\n  # Data with superimposed regression lines and noise distributions:\n  nPanels=25\n  nPlots = ceiling(nSubj/nPanels)\n  for ( plotIdx in 1:nPlots ) {\n    openGraph()\n    par( mar=c(2,2,1,0)+.5 , mgp=c(1.5,0.5,0) )\n    layout(matrix(1:nPanels,nrow=5,byrow=TRUE))\n    xRang = max(x)-min(x)\n    yRang = max(y)-min(y)\n    xLimMult = 0.1\n    yLimMult = 0.1\n    xLim= c( min(x)-xLimMult*xRang , max(x)+xLimMult*xRang )\n    yLim= c( min(y)-yLimMult*yRang , max(y)+yLimMult*yRang )\n    #for ( sIdx in unique(ceiling(seq(1,nSubj,length=nPanels))) ) { \n    for ( sIdx in ((plotIdx-1)*nPanels+1):min(nSubj,(plotIdx-1)*nPanels+nPanels)) { \n      thisSrows = (as.numeric(s)==sIdx)\n      plot( x[thisSrows] , y[thisSrows] , \n            cex=1.0 , lwd=1 , col=\"black\" , xlim=xLim , ylim=yLim ,\n            xlab=xName , ylab=yName , cex.lab=1.0 ,\n            main=paste0(\"Unit: \",levels(s)[sIdx]) , \n            cex.main=1.0  )\n      # Superimpose a smattering of believable regression lines:\n      nPredCurves=30\n      xComb = seq(xLim[1],xLim[2],length=301)\n      for ( i in floor(seq(1,chainLength,length=nPredCurves)) ) {\n        b0 = mcmcMat[i,paste0(\"beta0[\",sIdx,\"]\")]\n        b1 = mcmcMat[i,paste0(\"beta1[\",sIdx,\"]\")]\n        b2 = mcmcMat[i,paste0(\"beta2[\",sIdx,\"]\")]\n        lines( xComb , b0+b1*xComb+b2*xComb^2 , col=\"skyblue\" )\n      }\n      points( x[thisSrows] , y[thisSrows] , pch=19 )\n    }\n    if ( !is.null(saveName) ) {\n      saveGraph( file=paste0(saveName,\"PostPredSubj\",plotIdx), type=saveType)\n    }\n  }\n  #-----------------------------------------------------------------------------\n  # Data with superimposed regression lines and noise distributions:\n  openGraph()\n  par( mar=c(2,2,1,0)+.5 , mgp=c(1.5,0.5,0) )\n  # Plot data values:\n  xRang = max(x)-min(x)\n  yRang = max(y)-min(y)\n  xLimMult = 0.2\n  yLimMult = 0.2\n  xLim= c( min(x)-xLimMult*xRang , max(x)+xLimMult*xRang )\n  yLim= c( min(y)-yLimMult*yRang , max(y)+yLimMult*yRang )\n  plot( x , y , pch=\"\" , cex=1.0 , col=\"black\" , \n        xlim=xLim , ylim=yLim ,\n        xlab=xName , ylab=yName , cex.lab=1.0 ,\n        main=\"All Units\" , cex.main=1.0  )\n  # Superimpose a smattering of believable regression lines:\n  nPredCurves=70\n  xComb = seq(xLim[1],xLim[2],length=301)\n  for ( i in floor(seq(1,chainLength,length=nPredCurves)) ) {\n    b0 = mcmcMat[i,paste0(\"beta0mu\")]\n    b1 = mcmcMat[i,paste0(\"beta1mu\")]\n    b2 = mcmcMat[i,paste0(\"beta2mu\")]\n    lines( xComb , b0+b1*xComb+b2*xComb^2 , col=\"skyblue\" )\n  }\n  for ( sIdx in 1:nSubj ) {\n    thisSrows = (as.numeric(s)==sIdx)\n    lines( x[thisSrows] , y[thisSrows] , type=\"o\" , pch=19 ) #, pch=sIdx , col=sIdx )\n  }\n  #\n  if ( !is.null(saveName) ) {\n    saveGraph( file=paste(saveName,\"PostPredAll\",sep=\"\"), type=saveType)\n  }\n}\n\n#===============================================================================\n",
    "created" : 1493671829084.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2488058469",
    "id" : "63FF2AB2",
    "lastKnownWriteTime" : 1493681209,
    "last_content_update" : 1493681209564,
    "path" : "~/Google Drive/joint-modeling/reversal-learning/behavioral-analysis/Stan_for_RLP.R",
    "project_path" : "Stan_for_RLP.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}